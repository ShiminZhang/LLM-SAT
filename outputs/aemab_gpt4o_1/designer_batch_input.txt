{"custom_id": "req-0001", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are designing a restart trigger policy for the Kissat-MAB SAT solver to optimize performance on SAT Competition 2025 benchmarks (400 instances, PAR-2 scoring).\n\n### Task\nDesign a restart trigger algorithm (conceptual, not code) that decides WHEN the solver should restart. Your policy will replace the `kissat_restarting()` function and must:\n- Return a boolean decision (restart now: true/false)\n- Run in O(1) amortized time per call\n- Use only the signals listed below\n- Improve PAR-2 score over baseline\n\n### Search Mode Context\n\n**Focused Mode** (solver->stable = false):\n- Uses VSIDS or CHB heuristic (determined by MAB in stable mode)\n- Baseline trigger: restart when fast_glue exceeds slow_glue by margin%\n- Restart limit updated after each restart: conflicts + restartint + log(restarts)\n\n**Stable Mode** (solver->stable = true):\n- Uses reluctant doubling (Luby sequence) for restart intervals\n- MAB selects between heuristics (VSIDS=0, CHB=1) after each restart\n- Baseline trigger: reluctant.trigger flag via Luby sequence\n\n**Key Insight**: MAB heuristic selection happens OUTSIDE this function (in restart_mab). Your trigger can observe MAB performance signals to make smarter restart timing decisions.\n\n### Available Signals\n\n**Required Guards** (must check these):\n- `solver->unassigned` (unsigned) — unassigned variables remaining; must be > 0\n- `solver->level` (unsigned) — current decision level; must be > 0\n- `GET_OPTION(restart)` (int) — restarts enabled flag; must be true\n\n**Core Statistics** (use macros):\n- `CONFLICTS` — total conflicts (uint64_t) [macro for solver->statistics.conflicts]\n- `DECISIONS` — total decisions (uint64_t) [macro for solver->statistics.decisions]\n- `solver->statistics.restarts` (uint64_t) — total restart count\n\n**Restart Limits**:\n- `solver->limits.restart.conflicts` (uint64_t) — next scheduled restart threshold\n\n**Quality Metrics** (use macros):\n- `AVERAGE(fast_glue)` (double) — recent learned clause glue EMA [macro for solver->averages[solver->stable].fast_glue.value]\n- `AVERAGE(slow_glue)` (double) — baseline learned clause glue EMA\n- `AVERAGE(decision_rate)` (double) — decisions per conflict EMA\n\n**Configuration Options**:\n- `GET_OPTION(restartmargin)` (int) — glue margin percentage (default: 10, range: 0-25)\n- `GET_OPTION(restartint)` (int) — base restart interval (default: varies by version)\n\n**MAB Performance Signals** (stable mode only):\n- `solver->mab` (bool) — MAB enabled flag\n- `solver->heuristic` (unsigned) — active heuristic: 0=VSIDS, 1=CHB\n- `solver->mab_reward[0]` (double) — cumulative reward for VSIDS\n- `solver->mab_reward[1]` (double) — cumulative reward for CHB\n  * Reward formula: log₂(decisions) / log₂(conflicts) since last restart\n  * Higher reward = more solving progress per conflict\n- `solver->mab_select[0]` (unsigned) — times VSIDS selected\n- `solver->mab_select[1]` (unsigned) — times CHB selected\n- `solver->mab_decisions` (double) — decisions made since last restart\n- `solver->mab_conflicts` (unsigned) — conflicts since last restart\n- `solver->mab_chosen_tot` (unsigned) — total variable selections since last restart\n- `solver->mabc` (double) — UCB exploration constant C\n\n**Helper Functions Available**:\n- `kissat_reluctant_triggered(&solver->reluctant)` → bool (stable mode Luby trigger)\n\n### Output Format (JSON only)\n{\n  \"name\": \"Brief algorithm name (≤6 words)\",\n  \"algorithm\": \"Detailed restart trigger logic. Specify conditions for returning true (restart) vs false (continue). Handle both stable and focused modes. Include quantitative thresholds and tie-breakers.\",\n  \"reason\": \"Why this improves restart timing using MAB signals (2-3 sentences max). Focus on adaptive benefits for diverse SAT Competition instances.\"\n}\n\n### Constraints\n- Do NOT modify MAB state (mab_reward, mab_select, heuristic) — only observe\n- Do NOT call kissat_restart() or restart_mab() — this function only decides the trigger\n- Must respect baseline behavior unless strong justification: stable mode reluctant doubling is well-tested\n- Avoid magic numbers; use GET_OPTION() for configurable parameters\n\n### Baseline Reference\n**Current focused mode**: `return (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue)`\n**Current stable mode**: `return (CONFLICTS >= limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant)`"}], "temperature": 0.7}}
{"custom_id": "req-0002", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are designing a restart trigger policy for the Kissat-MAB SAT solver to optimize performance on SAT Competition 2025 benchmarks (400 instances, PAR-2 scoring).\n\n### Task\nDesign a restart trigger algorithm (conceptual, not code) that decides WHEN the solver should restart. Your policy will replace the `kissat_restarting()` function and must:\n- Return a boolean decision (restart now: true/false)\n- Run in O(1) amortized time per call\n- Use only the signals listed below\n- Improve PAR-2 score over baseline\n\n### Search Mode Context\n\n**Focused Mode** (solver->stable = false):\n- Uses VSIDS or CHB heuristic (determined by MAB in stable mode)\n- Baseline trigger: restart when fast_glue exceeds slow_glue by margin%\n- Restart limit updated after each restart: conflicts + restartint + log(restarts)\n\n**Stable Mode** (solver->stable = true):\n- Uses reluctant doubling (Luby sequence) for restart intervals\n- MAB selects between heuristics (VSIDS=0, CHB=1) after each restart\n- Baseline trigger: reluctant.trigger flag via Luby sequence\n\n**Key Insight**: MAB heuristic selection happens OUTSIDE this function (in restart_mab). Your trigger can observe MAB performance signals to make smarter restart timing decisions.\n\n### Available Signals\n\n**Required Guards** (must check these):\n- `solver->unassigned` (unsigned) — unassigned variables remaining; must be > 0\n- `solver->level` (unsigned) — current decision level; must be > 0\n- `GET_OPTION(restart)` (int) — restarts enabled flag; must be true\n\n**Core Statistics** (use macros):\n- `CONFLICTS` — total conflicts (uint64_t) [macro for solver->statistics.conflicts]\n- `DECISIONS` — total decisions (uint64_t) [macro for solver->statistics.decisions]\n- `solver->statistics.restarts` (uint64_t) — total restart count\n\n**Restart Limits**:\n- `solver->limits.restart.conflicts` (uint64_t) — next scheduled restart threshold\n\n**Quality Metrics** (use macros):\n- `AVERAGE(fast_glue)` (double) — recent learned clause glue EMA [macro for solver->averages[solver->stable].fast_glue.value]\n- `AVERAGE(slow_glue)` (double) — baseline learned clause glue EMA\n- `AVERAGE(decision_rate)` (double) — decisions per conflict EMA\n\n**Configuration Options**:\n- `GET_OPTION(restartmargin)` (int) — glue margin percentage (default: 10, range: 0-25)\n- `GET_OPTION(restartint)` (int) — base restart interval (default: varies by version)\n\n**MAB Performance Signals** (stable mode only):\n- `solver->mab` (bool) — MAB enabled flag\n- `solver->heuristic` (unsigned) — active heuristic: 0=VSIDS, 1=CHB\n- `solver->mab_reward[0]` (double) — cumulative reward for VSIDS\n- `solver->mab_reward[1]` (double) — cumulative reward for CHB\n  * Reward formula: log₂(decisions) / log₂(conflicts) since last restart\n  * Higher reward = more solving progress per conflict\n- `solver->mab_select[0]` (unsigned) — times VSIDS selected\n- `solver->mab_select[1]` (unsigned) — times CHB selected\n- `solver->mab_decisions` (double) — decisions made since last restart\n- `solver->mab_conflicts` (unsigned) — conflicts since last restart\n- `solver->mab_chosen_tot` (unsigned) — total variable selections since last restart\n- `solver->mabc` (double) — UCB exploration constant C\n\n**Helper Functions Available**:\n- `kissat_reluctant_triggered(&solver->reluctant)` → bool (stable mode Luby trigger)\n\n### Output Format (JSON only)\n{\n  \"name\": \"Brief algorithm name (≤6 words)\",\n  \"algorithm\": \"Detailed restart trigger logic. Specify conditions for returning true (restart) vs false (continue). Handle both stable and focused modes. Include quantitative thresholds and tie-breakers.\",\n  \"reason\": \"Why this improves restart timing using MAB signals (2-3 sentences max). Focus on adaptive benefits for diverse SAT Competition instances.\"\n}\n\n### Constraints\n- Do NOT modify MAB state (mab_reward, mab_select, heuristic) — only observe\n- Do NOT call kissat_restart() or restart_mab() — this function only decides the trigger\n- Must respect baseline behavior unless strong justification: stable mode reluctant doubling is well-tested\n- Avoid magic numbers; use GET_OPTION() for configurable parameters\n\n### Baseline Reference\n**Current focused mode**: `return (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue)`\n**Current stable mode**: `return (CONFLICTS >= limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant)`"}], "temperature": 0.7}}
{"custom_id": "req-0003", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are designing a restart trigger policy for the Kissat-MAB SAT solver to optimize performance on SAT Competition 2025 benchmarks (400 instances, PAR-2 scoring).\n\n### Task\nDesign a restart trigger algorithm (conceptual, not code) that decides WHEN the solver should restart. Your policy will replace the `kissat_restarting()` function and must:\n- Return a boolean decision (restart now: true/false)\n- Run in O(1) amortized time per call\n- Use only the signals listed below\n- Improve PAR-2 score over baseline\n\n### Search Mode Context\n\n**Focused Mode** (solver->stable = false):\n- Uses VSIDS or CHB heuristic (determined by MAB in stable mode)\n- Baseline trigger: restart when fast_glue exceeds slow_glue by margin%\n- Restart limit updated after each restart: conflicts + restartint + log(restarts)\n\n**Stable Mode** (solver->stable = true):\n- Uses reluctant doubling (Luby sequence) for restart intervals\n- MAB selects between heuristics (VSIDS=0, CHB=1) after each restart\n- Baseline trigger: reluctant.trigger flag via Luby sequence\n\n**Key Insight**: MAB heuristic selection happens OUTSIDE this function (in restart_mab). Your trigger can observe MAB performance signals to make smarter restart timing decisions.\n\n### Available Signals\n\n**Required Guards** (must check these):\n- `solver->unassigned` (unsigned) — unassigned variables remaining; must be > 0\n- `solver->level` (unsigned) — current decision level; must be > 0\n- `GET_OPTION(restart)` (int) — restarts enabled flag; must be true\n\n**Core Statistics** (use macros):\n- `CONFLICTS` — total conflicts (uint64_t) [macro for solver->statistics.conflicts]\n- `DECISIONS` — total decisions (uint64_t) [macro for solver->statistics.decisions]\n- `solver->statistics.restarts` (uint64_t) — total restart count\n\n**Restart Limits**:\n- `solver->limits.restart.conflicts` (uint64_t) — next scheduled restart threshold\n\n**Quality Metrics** (use macros):\n- `AVERAGE(fast_glue)` (double) — recent learned clause glue EMA [macro for solver->averages[solver->stable].fast_glue.value]\n- `AVERAGE(slow_glue)` (double) — baseline learned clause glue EMA\n- `AVERAGE(decision_rate)` (double) — decisions per conflict EMA\n\n**Configuration Options**:\n- `GET_OPTION(restartmargin)` (int) — glue margin percentage (default: 10, range: 0-25)\n- `GET_OPTION(restartint)` (int) — base restart interval (default: varies by version)\n\n**MAB Performance Signals** (stable mode only):\n- `solver->mab` (bool) — MAB enabled flag\n- `solver->heuristic` (unsigned) — active heuristic: 0=VSIDS, 1=CHB\n- `solver->mab_reward[0]` (double) — cumulative reward for VSIDS\n- `solver->mab_reward[1]` (double) — cumulative reward for CHB\n  * Reward formula: log₂(decisions) / log₂(conflicts) since last restart\n  * Higher reward = more solving progress per conflict\n- `solver->mab_select[0]` (unsigned) — times VSIDS selected\n- `solver->mab_select[1]` (unsigned) — times CHB selected\n- `solver->mab_decisions` (double) — decisions made since last restart\n- `solver->mab_conflicts` (unsigned) — conflicts since last restart\n- `solver->mab_chosen_tot` (unsigned) — total variable selections since last restart\n- `solver->mabc` (double) — UCB exploration constant C\n\n**Helper Functions Available**:\n- `kissat_reluctant_triggered(&solver->reluctant)` → bool (stable mode Luby trigger)\n\n### Output Format (JSON only)\n{\n  \"name\": \"Brief algorithm name (≤6 words)\",\n  \"algorithm\": \"Detailed restart trigger logic. Specify conditions for returning true (restart) vs false (continue). Handle both stable and focused modes. Include quantitative thresholds and tie-breakers.\",\n  \"reason\": \"Why this improves restart timing using MAB signals (2-3 sentences max). Focus on adaptive benefits for diverse SAT Competition instances.\"\n}\n\n### Constraints\n- Do NOT modify MAB state (mab_reward, mab_select, heuristic) — only observe\n- Do NOT call kissat_restart() or restart_mab() — this function only decides the trigger\n- Must respect baseline behavior unless strong justification: stable mode reluctant doubling is well-tested\n- Avoid magic numbers; use GET_OPTION() for configurable parameters\n\n### Baseline Reference\n**Current focused mode**: `return (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue)`\n**Current stable mode**: `return (CONFLICTS >= limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant)`"}], "temperature": 0.7}}
{"custom_id": "req-0004", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are designing a restart trigger policy for the Kissat-MAB SAT solver to optimize performance on SAT Competition 2025 benchmarks (400 instances, PAR-2 scoring).\n\n### Task\nDesign a restart trigger algorithm (conceptual, not code) that decides WHEN the solver should restart. Your policy will replace the `kissat_restarting()` function and must:\n- Return a boolean decision (restart now: true/false)\n- Run in O(1) amortized time per call\n- Use only the signals listed below\n- Improve PAR-2 score over baseline\n\n### Search Mode Context\n\n**Focused Mode** (solver->stable = false):\n- Uses VSIDS or CHB heuristic (determined by MAB in stable mode)\n- Baseline trigger: restart when fast_glue exceeds slow_glue by margin%\n- Restart limit updated after each restart: conflicts + restartint + log(restarts)\n\n**Stable Mode** (solver->stable = true):\n- Uses reluctant doubling (Luby sequence) for restart intervals\n- MAB selects between heuristics (VSIDS=0, CHB=1) after each restart\n- Baseline trigger: reluctant.trigger flag via Luby sequence\n\n**Key Insight**: MAB heuristic selection happens OUTSIDE this function (in restart_mab). Your trigger can observe MAB performance signals to make smarter restart timing decisions.\n\n### Available Signals\n\n**Required Guards** (must check these):\n- `solver->unassigned` (unsigned) — unassigned variables remaining; must be > 0\n- `solver->level` (unsigned) — current decision level; must be > 0\n- `GET_OPTION(restart)` (int) — restarts enabled flag; must be true\n\n**Core Statistics** (use macros):\n- `CONFLICTS` — total conflicts (uint64_t) [macro for solver->statistics.conflicts]\n- `DECISIONS` — total decisions (uint64_t) [macro for solver->statistics.decisions]\n- `solver->statistics.restarts` (uint64_t) — total restart count\n\n**Restart Limits**:\n- `solver->limits.restart.conflicts` (uint64_t) — next scheduled restart threshold\n\n**Quality Metrics** (use macros):\n- `AVERAGE(fast_glue)` (double) — recent learned clause glue EMA [macro for solver->averages[solver->stable].fast_glue.value]\n- `AVERAGE(slow_glue)` (double) — baseline learned clause glue EMA\n- `AVERAGE(decision_rate)` (double) — decisions per conflict EMA\n\n**Configuration Options**:\n- `GET_OPTION(restartmargin)` (int) — glue margin percentage (default: 10, range: 0-25)\n- `GET_OPTION(restartint)` (int) — base restart interval (default: varies by version)\n\n**MAB Performance Signals** (stable mode only):\n- `solver->mab` (bool) — MAB enabled flag\n- `solver->heuristic` (unsigned) — active heuristic: 0=VSIDS, 1=CHB\n- `solver->mab_reward[0]` (double) — cumulative reward for VSIDS\n- `solver->mab_reward[1]` (double) — cumulative reward for CHB\n  * Reward formula: log₂(decisions) / log₂(conflicts) since last restart\n  * Higher reward = more solving progress per conflict\n- `solver->mab_select[0]` (unsigned) — times VSIDS selected\n- `solver->mab_select[1]` (unsigned) — times CHB selected\n- `solver->mab_decisions` (double) — decisions made since last restart\n- `solver->mab_conflicts` (unsigned) — conflicts since last restart\n- `solver->mab_chosen_tot` (unsigned) — total variable selections since last restart\n- `solver->mabc` (double) — UCB exploration constant C\n\n**Helper Functions Available**:\n- `kissat_reluctant_triggered(&solver->reluctant)` → bool (stable mode Luby trigger)\n\n### Output Format (JSON only)\n{\n  \"name\": \"Brief algorithm name (≤6 words)\",\n  \"algorithm\": \"Detailed restart trigger logic. Specify conditions for returning true (restart) vs false (continue). Handle both stable and focused modes. Include quantitative thresholds and tie-breakers.\",\n  \"reason\": \"Why this improves restart timing using MAB signals (2-3 sentences max). Focus on adaptive benefits for diverse SAT Competition instances.\"\n}\n\n### Constraints\n- Do NOT modify MAB state (mab_reward, mab_select, heuristic) — only observe\n- Do NOT call kissat_restart() or restart_mab() — this function only decides the trigger\n- Must respect baseline behavior unless strong justification: stable mode reluctant doubling is well-tested\n- Avoid magic numbers; use GET_OPTION() for configurable parameters\n\n### Baseline Reference\n**Current focused mode**: `return (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue)`\n**Current stable mode**: `return (CONFLICTS >= limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant)`"}], "temperature": 0.7}}
{"custom_id": "req-0005", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are designing a restart trigger policy for the Kissat-MAB SAT solver to optimize performance on SAT Competition 2025 benchmarks (400 instances, PAR-2 scoring).\n\n### Task\nDesign a restart trigger algorithm (conceptual, not code) that decides WHEN the solver should restart. Your policy will replace the `kissat_restarting()` function and must:\n- Return a boolean decision (restart now: true/false)\n- Run in O(1) amortized time per call\n- Use only the signals listed below\n- Improve PAR-2 score over baseline\n\n### Search Mode Context\n\n**Focused Mode** (solver->stable = false):\n- Uses VSIDS or CHB heuristic (determined by MAB in stable mode)\n- Baseline trigger: restart when fast_glue exceeds slow_glue by margin%\n- Restart limit updated after each restart: conflicts + restartint + log(restarts)\n\n**Stable Mode** (solver->stable = true):\n- Uses reluctant doubling (Luby sequence) for restart intervals\n- MAB selects between heuristics (VSIDS=0, CHB=1) after each restart\n- Baseline trigger: reluctant.trigger flag via Luby sequence\n\n**Key Insight**: MAB heuristic selection happens OUTSIDE this function (in restart_mab). Your trigger can observe MAB performance signals to make smarter restart timing decisions.\n\n### Available Signals\n\n**Required Guards** (must check these):\n- `solver->unassigned` (unsigned) — unassigned variables remaining; must be > 0\n- `solver->level` (unsigned) — current decision level; must be > 0\n- `GET_OPTION(restart)` (int) — restarts enabled flag; must be true\n\n**Core Statistics** (use macros):\n- `CONFLICTS` — total conflicts (uint64_t) [macro for solver->statistics.conflicts]\n- `DECISIONS` — total decisions (uint64_t) [macro for solver->statistics.decisions]\n- `solver->statistics.restarts` (uint64_t) — total restart count\n\n**Restart Limits**:\n- `solver->limits.restart.conflicts` (uint64_t) — next scheduled restart threshold\n\n**Quality Metrics** (use macros):\n- `AVERAGE(fast_glue)` (double) — recent learned clause glue EMA [macro for solver->averages[solver->stable].fast_glue.value]\n- `AVERAGE(slow_glue)` (double) — baseline learned clause glue EMA\n- `AVERAGE(decision_rate)` (double) — decisions per conflict EMA\n\n**Configuration Options**:\n- `GET_OPTION(restartmargin)` (int) — glue margin percentage (default: 10, range: 0-25)\n- `GET_OPTION(restartint)` (int) — base restart interval (default: varies by version)\n\n**MAB Performance Signals** (stable mode only):\n- `solver->mab` (bool) — MAB enabled flag\n- `solver->heuristic` (unsigned) — active heuristic: 0=VSIDS, 1=CHB\n- `solver->mab_reward[0]` (double) — cumulative reward for VSIDS\n- `solver->mab_reward[1]` (double) — cumulative reward for CHB\n  * Reward formula: log₂(decisions) / log₂(conflicts) since last restart\n  * Higher reward = more solving progress per conflict\n- `solver->mab_select[0]` (unsigned) — times VSIDS selected\n- `solver->mab_select[1]` (unsigned) — times CHB selected\n- `solver->mab_decisions` (double) — decisions made since last restart\n- `solver->mab_conflicts` (unsigned) — conflicts since last restart\n- `solver->mab_chosen_tot` (unsigned) — total variable selections since last restart\n- `solver->mabc` (double) — UCB exploration constant C\n\n**Helper Functions Available**:\n- `kissat_reluctant_triggered(&solver->reluctant)` → bool (stable mode Luby trigger)\n\n### Output Format (JSON only)\n{\n  \"name\": \"Brief algorithm name (≤6 words)\",\n  \"algorithm\": \"Detailed restart trigger logic. Specify conditions for returning true (restart) vs false (continue). Handle both stable and focused modes. Include quantitative thresholds and tie-breakers.\",\n  \"reason\": \"Why this improves restart timing using MAB signals (2-3 sentences max). Focus on adaptive benefits for diverse SAT Competition instances.\"\n}\n\n### Constraints\n- Do NOT modify MAB state (mab_reward, mab_select, heuristic) — only observe\n- Do NOT call kissat_restart() or restart_mab() — this function only decides the trigger\n- Must respect baseline behavior unless strong justification: stable mode reluctant doubling is well-tested\n- Avoid magic numbers; use GET_OPTION() for configurable parameters\n\n### Baseline Reference\n**Current focused mode**: `return (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue)`\n**Current stable mode**: `return (CONFLICTS >= limits.restart.conflicts) && kissat_reluctant_triggered(&solver->reluctant)`"}], "temperature": 0.7}}
