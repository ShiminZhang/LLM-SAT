  You are an AI researcher specializing in CDCL restart policies. Propose a new restart policy algorithm for the Kissat SAT solver.

A SAT solver’s restart policy controls when the solver abandons its current search path and begins a fresh search. The idea is that, instead of staying too long in an unproductive part of the search space, the solver resets to a clean state while keeping learned clauses. Restarts are triggered according to predefined rules—such as fixed intervals, geometric growth, or activity-based signals—so the solver can explore new regions more effectively and avoid getting stuck.

You should start by thinking what defines a good restart policy, and how to make a good restart policy.

### Task
Design a restart policy (conceptual, not code) to maximize solver performance (solved instances, PAR-2). Your policy must:
- Define a restart trigger/score and when a restart fires.
- Provide quantitative rules and tie-breakers.
- Run in O(1) or O(log n) per conflict.
- Use only the signals listed below.
- Include a brief rationale for expected gains.
- Give an algorithm that ONLY answers "when to restart", do not answer "what to do when restart"

### Available Internal Signals
- is stable stage — source: solver->stable
- level — source: solver->level
- number of conflicts — source: solver->statistics.conflicts
- number of decisions — source: solver->statistics.decisions
- limit of conflicts — source: solver->limits.restart.conflicts
- fast averge of glue — source: solver->averages[solver->stable].fast_glue.value
- slow averge of glue — source: solver->averages[solver->stable].slow_glue.value
- decision rate moving average — source: solver->averages[solver->stable].decision_rate.value

### Output Format (JSON only)
1. Algorithm Name – concise title
2. Algorithm
3. Reason – argue why this is a good restart policy, keet this short

### Constraints
- Use only the listed signals.
- Keep explanations formal, concise, algorithmic.

### Final Instruction
Act as a SAT-solver algorithm designer. Produce a single, self-contained restart policy description implementable inside Kissat’s restart logic.

Example Algorithms that achieve good performance and compilation rate:
1.
  "Algorithm": [
    "At each conflict, compute:",
    "  - Gf = fast average glue",
    "  - Gs = slow average glue",
    "  - DR = decision rate moving average",
    "Maintain two restart triggers:",
    "  1. Glue Agitation Trigger: If Gf > Gs + δ_g (δ_g = 2.0), set glue_trigger = true.",
    "  2. Decision Stagnation Trigger: If DR < θ_dr (θ_dr = 0.1), set decision_trigger = true.",
    "Tie-breaker: If both triggers fire, restart immediately.",
    "Otherwise: Restart if either trigger is true AND solver is not in stable stage (is stable stage == false).",
    "If neither trigger is true, defer restart until reaching conflict limit (limit of conflicts).",
    "Upon restart, reset only the triggers; do not reset averages."
  ],
2.
  "Algorithm": [
    "At each conflict, compute the following restart score:",
    "    score = (fast_glue / max(1, slow_glue)) * (1 / max(1e-6, decision_rate))",
    "Define thresholds: glue_ratio_threshold = 1.15, decision_rate_threshold = 0.8 * initial_decision_rate;",
    "A restart is triggered if either:",
    "  (1) (fast_glue / slow_glue) > glue_ratio_threshold",
    "      // indicates recent conflict clauses are lower quality than historical average;",
    "  OR",
    "  (2) decision_rate < decision_rate_threshold",
    "      // indicates search is stalling in current region;",
    "Additionally, always enforce a hard conflict upper limit per phase via limit_of_conflicts to guarantee progress.",
    "Tie-breaker: If both (1) and (2) trigger, restart only if current level > 0 (i.e., not at root), else delay until next non-root conflict."
  ],