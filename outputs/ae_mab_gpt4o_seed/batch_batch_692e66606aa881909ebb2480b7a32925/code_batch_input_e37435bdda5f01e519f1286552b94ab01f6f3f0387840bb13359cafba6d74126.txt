{"custom_id": "req-0001", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0002", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0003", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0004", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0005", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0006", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0007", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0008", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0009", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
{"custom_id": "req-0010", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-4o", "input": [{"role": "system", "content": "You are an AI researcher specialising in SAT solver heuristics."}, {"role": "user", "content": "You are implementing a restart trigger for the Kissat-MAB SAT solver. Generate the complete `kissat_restarting` function with signature and body.\n\n### Requirements\n- Output complete function: `bool kissat_restarting(kissat *solver) { ... }`\n- Must compile with existing Kissat-MAB codebase\n- First line must be: `assert(solver->unassigned);`\n- Return `true` to trigger restart, `false` to continue search\n\n### Available Headers (already included in restart.c)\n```c\n#include \"restart.h\"\n#include \"internal.h\"  // Provides access to solver struct and all subsystems\n#include \"reluctant.h\"\n#include <inttypes.h>\n#include <math.h>\n```\n\n### Available Macros\n\n**Statistics**:\n- `CONFLICTS` → `solver->statistics.conflicts`\n- `DECISIONS` → `solver->statistics.decisions`\n\n**Averages** (automatically selects focused/stable):\n- `AVERAGE(fast_glue)` → `solver->averages[solver->stable].fast_glue.value`\n- `AVERAGE(slow_glue)` → `solver->averages[solver->stable].slow_glue.value`\n- `AVERAGE(decision_rate)` → `solver->averages[solver->stable].decision_rate.value`\n\n**Options**:\n- `GET_OPTION(restart)` → `solver->options.restart` (bool-like int)\n- `GET_OPTION(restartmargin)` → `solver->options.restartmargin` (int 0-25)\n- `GET_OPTION(restartint)` → `solver->options.restartint` (int)\n\n### Available Signals\n\n**State**:\n```c\nsolver->stable          // bool: true=stable mode, false=focused mode\nsolver->level           // unsigned: current decision level\nsolver->unassigned      // unsigned: unassigned variables count\n```\n\n**Statistics**:\n```c\nCONFLICTS                        // uint64_t (macro)\nDECISIONS                        // uint64_t (macro)\nsolver->statistics.restarts      // uint64_t\n```\n\n**Limits**:\n```c\nsolver->limits.restart.conflicts // uint64_t: next restart threshold\n```\n\n**Quality Metrics**:\n```c\nAVERAGE(fast_glue)      // double (macro): recent clause quality EMA\nAVERAGE(slow_glue)      // double (macro): baseline clause quality EMA\nAVERAGE(decision_rate)  // double (macro): decisions/conflict EMA\n```\n\n**MAB Signals** (observe only, do not modify):\n```c\nsolver->mab              // bool: MAB enabled\nsolver->heuristic        // unsigned: 0=VSIDS, 1=CHB\nsolver->mab_reward[0]    // double: VSIDS cumulative reward\nsolver->mab_reward[1]    // double: CHB cumulative reward\nsolver->mab_select[0]    // unsigned: VSIDS selection count\nsolver->mab_select[1]    // unsigned: CHB selection count\nsolver->mab_decisions    // double: decisions since last restart\nsolver->mab_conflicts    // unsigned: conflicts since last restart\nsolver->mab_chosen_tot   // unsigned: variable selections since last restart\nsolver->mabc             // double: UCB exploration constant\n```\n\n### Available Functions\n\n**Required**:\n- `assert(condition)` — assertion (required as first line)\n\n**Helpers**:\n- `kissat_reluctant_triggered(reluctant *r)` → `bool`\n  Usage: `kissat_reluctant_triggered(&solver->reluctant)`\n\n- `kissat_extremely_verbose(kissat *s, const char *fmt, ...)` → `void`\n  Optional logging for debugging\n\n**Math** (from math.h):\n- `log(double)`, `log2(double)`, `sqrt(double)`, etc.\n\n### Algorithm to Implement\n{algorithm}\n\n### Output Format\nWrap your complete function in `<code>` tags (no other text outside tags):\n\n<code>\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n\n  // Your implementation here\n\n  return /* true or false */;\n}\n</code>\n\n### Compilation Constraints\n- Do NOT declare new struct types\n- Do NOT use static variables (function is called frequently)\n- Do NOT modify solver state (read-only access)\n- Do NOT include additional headers\n- Do NOT call restart execution functions (kissat_restart, restart_mab)\n\n### Baseline Reference (original implementation)\n```c\nbool kissat_restarting(kissat *solver) {\n  assert(solver->unassigned);\n  if (!GET_OPTION(restart))\n    return false;\n  if (!solver->level)\n    return false;\n  if (CONFLICTS < solver->limits.restart.conflicts)\n    return false;\n  if (solver->stable)\n    return kissat_reluctant_triggered(&solver->reluctant);\n  const double fast = AVERAGE(fast_glue);\n  const double slow = AVERAGE(slow_glue);\n  const double margin = (100.0 + GET_OPTION(restartmargin)) / 100.0;\n  const double limit = margin * slow;\n  return (limit <= fast);\n}\n```\n\n**Key points**:\n- Lines 2-7: Required guard conditions\n- Line 9: Stable mode uses reluctant doubling\n- Lines 10-15: Focused mode uses glue ratio with configurable margin\n\nAlgorithm:\n{\"id\": \"batch_req_692e66e4f5cc81909c6422f527855fa7\", \"custom_id\": \"req-0002\", \"response\": {\"status_code\": 200, \"request_id\": \"32f8c20957888bf2ea6d29c8aa7167e4\", \"body\": {\"id\": \"resp_0aed813f9decfef600692e66a2b7f88191a052e58e43e6a02b\", \"object\": \"response\", \"created_at\": 1764648610, \"status\": \"completed\", \"background\": false, \"billing\": {\"payer\": \"developer\"}, \"error\": null, \"incomplete_details\": null, \"instructions\": null, \"max_output_tokens\": null, \"max_tool_calls\": null, \"model\": \"gpt-4o-2024-08-06\", \"output\": [{\"id\": \"msg_0aed813f9decfef600692e66a333288191a687f18bfcfcd884\", \"type\": \"message\", \"status\": \"completed\", \"content\": [{\"type\": \"output_text\", \"annotations\": [], \"logprobs\": [], \"text\": \"```json\\n{\\n  \\\"name\\\": \\\"Adaptive MAB-Aware Restart\\\",\\n  \\\"algorithm\\\": \\\"In focused mode, return true if (CONFLICTS >= limits.restart.conflicts) && ((1.0 + margin/100.0) * slow_glue <= fast_glue). In stable mode, return true if (CONFLICTS >= limits.restart.conflicts) && (kissat_reluctant_triggered(&solver->reluctant) || adaptive_trigger). The adaptive_trigger is true if (solver->mab && (solver->mab_reward[solver->heuristic] < threshold)), where threshold = (solver->mab_reward[0] + solver->mab_reward[1]) / 2.0 * (1 - (solver->mab_chosen_tot / solver->mab_decisions)).\\\",\\n  \\\"reason\\\": \\\"This adaptive policy leverages MAB performance signals to adjust restart timing based on heuristic effectiveness. By incorporating MAB rewards and decision dynamics, it adapts to performance patterns across varied benchmarks, potentially improving solver efficiency and PAR-2 scores by restarting when heuristic performance declines.\\\"\\n}\\n```\"}], \"role\": \"assistant\"}], \"parallel_tool_calls\": true, \"previous_response_id\": null, \"prompt_cache_key\": null, \"prompt_cache_retention\": null, \"reasoning\": {\"effort\": null, \"summary\": null}, \"safety_identifier\": null, \"service_tier\": \"default\", \"store\": true, \"temperature\": 0.7, \"text\": {\"format\": {\"type\": \"text\"}, \"verbosity\": \"medium\"}, \"tool_choice\": \"auto\", \"tools\": [], \"top_logprobs\": 0, \"top_p\": 1.0, \"truncation\": \"disabled\", \"usage\": {\"input_tokens\": 1121, \"input_tokens_details\": {\"cached_tokens\": 0}, \"output_tokens\": 231, \"output_tokens_details\": {\"reasoning_tokens\": 0}, \"total_tokens\": 1352}, \"user\": null, \"metadata\": {}}}, \"error\": null}"}], "temperature": 0.7}}
